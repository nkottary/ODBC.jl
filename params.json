{"name":"ODBC.jl","tagline":"A low-level ODBC interface for the Julia programming language","body":"ODBC.jl\r\n=======\r\n[![Build Status](https://travis-ci.org/JuliaDB/ODBC.jl.png)](https://travis-ci.org/JuliaDB/ODBC.jl)\r\n\r\nA low-level ODBC interface for the Julia programming language\r\n\r\nInstallation through the Julia package manager:\r\n```julia\r\njulia> Pkg.init()        # Creates julia package repository (only runs once for all packages)\r\njulia> Pkg.add(\"ODBC\")   # Creates the ODBC repo folder and downloads the ODBC package + dependancy (if needed)\r\njulia> using ODBC        # Loads the ODBC module for use (needs to be run with each new Julia instance)\r\n```\r\n## Package Documentation\r\nExported functions, macros, types, and variables include:\r\n#### Functions\r\n* `ODBC.connect(dsn; usr=\"\", pwd=\"\")`\r\n\r\n  `ODBC.connect` requires the `dsn` string argument as the name of a pre-defined ODBC\r\ndatasource.  Valid datasources (DSNs) must first be setup through the ODBC\r\nadministrator (or IODBC, unixODBC, etc.) prior to connecting in Julia. Note the use of `ODBC.` before `connect`, this is to prevent method ambiguity with the `Base.connect` family of methods.\r\n\r\n  The `usr` and `pwd` named arguments are optional as they may already\r\nbe defined in the datasource.\r\n\r\n  `ODBC.connect` returns a `Connection` type which contains basic information\r\nabout the connection and ODBC handle pointers.\r\n\r\n  `ODBC.connect` can be used by storing the `Connection` type in\r\na variable to be able to disconnect or facilitate handling multiple\r\nconnections like so:\r\n  ```julia\r\n  co = ODBC.connect(\"mydatasource\",usr=\"johndoe\",pwd=\"12345\")\r\n  ```\r\n  But it's unneccesary to store the `Connection`, as an exported\r\n`conn` variable holds the most recently created `Connection` type and other\r\nODBC functions (i.e. `query`) will use it by default in the absence of a specified\r\nconnection.\r\n\r\n* `disconnect(connection::Connection=conn)`\r\n\r\n  `disconnect` closes a connection type, frees all handles and resets\r\nthe default connection `conn` as necessary. If invoked with no arguments\r\n(i.e. `disconnect()`), the default connection `conn` is closed.\r\n\r\n* `advancedconnect(conn_string::String)`\r\n\r\n  `advancedconnect` implements the native ODBC SQLDriverConnect function\r\nwhich allows flexibility in connecting to a datasource through specifying\r\na 'connection string' (e.g. \"DSN=userdsn;UID=johnjacob;PWD=jingle;\") See\r\nODBC API documentation (http://goo.gl/uXTuk) for additional details.\r\n\r\n  If the connection string doesn't contain enough information for the driver\r\nto connect, the user will be prompted with the additional information\r\nneeded.\r\n\r\n  Furthermore, on Windows, if `advancedconnect()` is called without arguments the ODBC\r\nadministrator will be brought up where the user can select the DSN to\r\nwhich to connect, even allowing the user to create a datasource or add a\r\ndriver.\r\n\r\n  (An excellent resource for learning how to construct connection strings\r\nfor various DBMS/driver configurations is\r\nhttp://www.connectionstrings.com/)\r\n\r\n* `query(connection::Connection=conn, querystring; file=:DataFrame,delim='\\t')`\r\n  \r\n  If a connection type isn't specified as the first positional argument, the query will be executed against\r\nthe default connection (stored in the exported variable `conn` if you'd like to\r\ninspect).\r\n\r\n  Once the query is executed, the resultset is stored in a\r\n`DataFrame` by default (`file=:DataFrame`). Otherwise, the user may specify\r\na file name to which the resultset is to be written, along with the desired\r\nfile delimiter (default `delim='\\t'`). Depending on DBMS capability, users may also\r\npass multiple query statements in a single query call and the resultsets\r\nwill be returned in an array of DataFrames, or the user may specify an array\r\nof filename strings and `Char` delimiters into which the results will be written. \r\n\r\n  For the general user, a simple `query(querystring)` is enough to return a single\r\nresultset in a DataFrame. Results are stored in the passed connection type's resultset field.\r\n(i.e. `conn.resultset`). Results are stored by default to avoid immediate garbarge collection\r\nand provide access for the user even if the resultset returned by `query()` isn't stored in a variable.\r\n\r\n* `querymeta(conn::Connection=conn, querystring; file=:DataFrame,delim='\\t')`\r\n \r\n  `querymeta` is really just the 1st half of the `query` function. A query string is sent to the DBMS, executed,\r\nand metadata (i.e. rows, columns, types, column names, etc.) is returned to the user, avoiding actually returning\r\nthe dataset. The returned information is actually stored in the `Metadata` type, so the information may be\r\nprogrammatically examined (try running `names(Metadata)` to see its fields). Running `querymeta` is useful \r\nfor inspecting the results of large queries while avoiding the overhead of returning the actual dataset into memory.\r\nThe function signature is identical to `query` for ease in switching between the two though `querymeta` ignores\r\nthe `file` and `delim` arguments.\r\n\r\n* `listdrivers()`\r\n\r\n  Takes no arguments. Returns a list of installed ODBC drivers registered in the ODBC administator (IODBC, unixODBC, etc.).\r\n* `listdsns()`\r\n\r\n  Takes no arguments. Returns a list of defined datasources (DSNs) registered in the ODBC administator \r\n  (IODBC, unixODBC, etc.). The datasource names can be used as the 1st argument in `ODBC.connect(dsn)`.\r\n#### Macros\r\n* `sql\"...\"`\r\n\r\n  `sql\"...\"` is a Julia string literal implemented by the `@sql_str` macro. It is equivalent to calling \r\n  `query(querystring)` as you can see from the actual definition below:\r\n  ```julia\r\n  macro sql_str(s)\r\n    query(s)\r\n  end\r\n  ```\r\n#### Types\r\n* `Connection`\r\n\r\n  Stores information about a DSN connection. Names include `dsn`, `number` (counts `Connection` types specific\r\nto each DSN), `dbc_ptr` and `stmt_ptr` as internal connection and statement handle pointers, and `resultset` which\r\nstores the last resultset returned from a `query` or `querymeta` call. \r\n\r\n* `Metadata`\r\n  Stores information about an executed query, returned by `querymeta`. Names include `querystring` (the query sent to\r\nbe executed), `cols` (# of columns in resultset), `rows` (# of rows in resultset), `colnames` (column names to be \r\nreturned in resultset), `coltypes` (SQL types of resultset columns), `colsizes` (size in bytes of resultset columns),\r\n`coldigits` (max number of digits for numeric resultset columns; though not always implemented correctly by ODBC driver),\r\nand `colnulls` (whether the resultset column is nullable).\r\n#### Variables\r\n* `conn`\r\n  Global, exported variable that initially holds a null `Connection` type until a connection is successfully made by\r\n`ODBC.connect` or `advancedconnect`. Is used by `query` and `querymeta` as the default datasource `Connection` if none is\r\nexplicitly specified. \r\n* `Connections`\r\n  Global, exported variable of type `Array{Connection,1}`, that holds `Connection` types. When multiple calls to `ODBC.connect`\r\nor `advancedconnect` are made, `Connections` stores each `Connection` type to manage the number of DSN connections. \r\nIt is also referenced when the default connection `conn` is disconnected and reset to `Connections[end]` if other \r\nconnections exist, or a null `Connection` type otherwise.\r\n\r\n### Known Issues\r\n* We've had limited ODBC testing between various platforms, so it may happen that `ODBC.jl` doesn't recognize your\r\n  ODBC shared library (also know as the Driver Manager, basically the middleman between `ODBC.jl` and the RDBMS).\r\n  The current approach is to check a variety of the most widely used ODBC libraries and produce an error if not found.\r\n  If this happens, you'll need to manually locate your ODBC shared library (searching for something along the lines of\r\n  `libodbc` or `libiodbc`, or installing it if you haven't yet) and then run the following:\r\n  ```julia\r\n  const odbc_dm = \"path/to/library/libodbc.so\" (or .dylib on OSX)\r\n  ```\r\n\r\n  *Note that the file is `odbc32` on Windows, but should never have a problem being found (ships by default).\r\n  That said, if you end up doing this, open an issue on GitHub to let me know what the name of your ODBC library is\r\nand I can add is as one of the defaults to check for.\r\n\r\n### TODO\r\n* Create SQL typealiases and use in conjunction with Julia-C typealiases for ODBC_API (for more transparency and because we can)\r\n* Metadata tools: This would involve specilized queries for examining DBMS schema, tables, views, columns, with \r\n  associated metadata and possibly statistics. I know the driver managers support SQLTables and SQLStatistics, \r\n  so it should be pretty simple to implement these.\r\n* Create, Update Table functions (also auto-detect regular queries as these kinds of DDL queries): Pretty self-explanatory.\r\n* Support more SQL data types: Date, Time, Intervals. Right now, all main bitstypes, character and binary formats\r\n  (short, long, float, double, char, etc.) are supported, but the date and time data types are read as strings. \r\n  Other implementations in C use structs to read them in and Julia is still fragile on struct support as far as I know.\r\n  As Julia struct compatibility improves it's an eventual (I think RODBC package still only reads dates as strings...)\r\n* Asynchronous querying: This might be a longshot, but the later ODBC API supports async querying through polling, \r\n  so it would be cool to find a way to implement this. I'm not sure how useful it would be long term or exactly how it\r\n  would be implemented (Call asyncquery() and then later call querydone() to see if it's finished?), but because the\r\n  underlying api is capable this could be some cool functionality.\r\n* How to deal with Unicode/ANSI function calling? (I think we're ok here, but not sure)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}